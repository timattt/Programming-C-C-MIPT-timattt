#pragma once

// RULES
/*
1. Каждая строка - нетерминал.
	ПРИМЕР: A ::=...; (Объявляем нетерминал А)
2. Скобки есть только квадратные для описания терминальных символов.
	ПРИМЕР: A ::=["abc"];(Нетерминал А определен как строка "abc")
3. Если используем оператор | (или), то в каждой части оператора может быть только один нетерминал И БОЛЬШЕ НИЧЕГО,
	приоритет идет слева.
	ПРИМЕР: A ::= B | C | D; (Если B подходит, то в A подставляется B, если нет, то проверяется C и т.д.)
4. Можно задавать терминальные символы в квадратных скобках.
	Внутри скобок выбирается строка, из заключенных в кавычки,
		если в кавычках поставить два символа и между ними тире, то может быть выбран любой символ,
			лежащий между этими двумя.
	ПРИМЕР: A ::= ["abc" "b-z"]; (Нетерминал А может быть одной из строк "abc" или одним символом из диапазона [b, z])
5. После нетерминала можно ставить следующие операторы:
	1. * - ноль или более.
	2. + - один или более.
	3. ? - ноль или один.
	ПРИМЕР: А ::= B*; (Пока нетерминал B присутствует он будет использован)
6. Нужно быть осторожным, когда есть два нетерминала с одинаковым началом.
7. Результат работы парсера - дерево, где каждая вершина - нетерминал, ее сыновья - нетерминалы, которые вызываются данным нетерминалом.
	В ней хранится значение, которое склеивается из значений сыновей. Если вершина - лист, то значит, что она формируется только из терминалов.
*/

#include "../../Storage/tList.hpp"
#include "../../Utilities/FileHandler.hpp"
#include "../../Utilities/String.hpp"

//! This function generates code for parser of grammar.
//! @param gr - file where grammar is.
//! @param dest - file where code will be stored.
void gramCreateParser(tFile *gr, tFile *dest);
