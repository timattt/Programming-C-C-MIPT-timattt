# Введение
Сей репозиторий содержит мои проекты, написанные в первом семестре обучения на ФРТК.
Из них можно выделить несколько, которые представляют наибольший интерес, краткая сводка по ним следует далее.

# Навигатор по репозиторию
[Интерпретатор и компилятор компиляторов](https://github.com/timattt/Programming-C-MIPT-timattt/tree/master/Programming%20Ded/tGrammarParser)  
[PE манипулятор](https://github.com/timattt/Programming-C-MIPT-timattt/tree/master/Programming%20Ded/tPE_Editor)  
[Эмулятор процессора и транслятор](https://github.com/timattt/Programming-C-MIPT-timattt/tree/master/Programming%20Ded/tProcessor)  

# Компилятор компиляторов
Пожалуй один из самых полезных проектов - алгоритм, позволяющий построить универсальный код для любой грамматики.
Полученный код сможет сгенерировать дерево грамматики для любой подходящей строки и дальнейшее взяимодействие с ним на усмотрение разработчика. (например можно начать исполнять это дерево, если оно представляет из себя последовательность команд (см. далее))

## Правила написания грамматики
- Каждая строка - нетерминал.
- Скобки есть только квадратные для описания терминальных символов.
- Если используем оператор | (или), то в каждой части оператора может быть только один нетерминал И БОЛЬШЕ НИЧЕГО,
приоритет идет слева.
- Можно задавать терминальные символы в квадратных скобках.
Внутри скобок выбирается строка, из заключенных в кавычки,
если в кавычках поставить два символа и между ними тире, то может быть выбран любой символ,
лежащий между этими двумя.
- После нетерминала можно ставить следующие операторы:
1. "*" - ноль или более.
2. "+" - один или более.
3. "?" - ноль или один.
- Нужно быть осторожным, когда есть два нетерминала с одинаковым началом.
- Результат работы парсера - дерево, где каждая вершина - нетерминал, ее сыновья - нетерминалы, которые вызываются данным нетерминалом.
В ней хранится значение, которое склеивается из значений сыновей. Если в определении вершины-нетерминала есть терминалы,
то они просто добавляются в значению данной вершины.

## Пример
Пусть мы хотим написать парсер, который будет анализировать строки вида имя, двоеточие, номер.

![Image of example](https://github.com/timattt/Programming-C-MIPT-timattt/blob/master/gram_example.png)

## Примеры грамматик
- __A ::=...;__  \(Объявляем нетерминал А)
- __A ::=["abc"];__  (Нетерминал А определен как строка "abc")
- __A ::= B | C | D;__  (Если B подходит, то в A используется B, если нет, то проверяется C и т.д.)
- __A ::= ["abc" "b-z"];__  (Нетерминал А может быть одной из строк "abc" или одним символом из диапазона [b, z])
- __А ::= B*;__  (Пока нетерминал B присутствует он будет использован)
- __A ::= ["abcd"]E;__
__B ::= ["abcd"]C;__ (C, E - другие нетерминалы)
__D ::= A | B;__ (Вот в этом месте может возникнуть неопределенность)
- __A ::= C;__
__C ::= B["de"];__
__B ::= "abc";__
Результат работы для строки "abcde" (это дерево, в скобках указано значение, которое лежит в вершине)
A("abcde") -> C("abcde") -> B("abc")

# Интерпретатор
В конце первого семестра я написал язык программирования, но это был интерпретируемый язык, т.е. он выполнялся непосредственно в виде дерева, без перехода в асм, синтаксис примерно похож на C.

Все это располагается в папке tGrammarParser.
Для использования предполагается снача обработать строку с исходным кодом через функции обработки грамматики (файл __tGrammarParser.h__) (обработка грамматики самодельная, когда я писал язык, компилятора компиляторов еще не было, так что код считается 'авто сгенерированным', поэтому доков в самом коде маловато),
запустить функции __init__ и __G__ (классический первый нетерминал)
Далее можно залезть в файл __tInterpritator.h__ и запустить функции __init__, дабы подключить к собственно интерпретатору само дерево, и функцию __run__. И все будет работать.

Вот простойт пример работы интерпретатора. Программа вычисляет значение (2*n)!
![](https://github.com/timattt/Programming-C-MIPT-timattt/blob/master/lang_example.png)

# Транслятор
Еще есть собственный асемблер (__tnasm__) с переводом в машинный код собственного формата, который запускается эмулятором. Код аналогичен обычному nasm. Однако, разумеется, было бы интересно получать из этого асм полноценный exe файл. Поэтому есть две опции: использовать транслятор и переводить машинный код __tnasm__ в машинный код windows (получать готовый PE файл). Или писать на специальной модификации tnasm, которая заточена специально под PE (помимо обычных команд процессора, есть еще сложные, который разворачиваются в несколько обычных, что существенно облегчает разработку (например команда пересылки данных из памяти в память)).

Чтобы всем этии воспользоваться, нужно использовать файл __tProcessor/tProcessor.h__ и его функции __tDisasm_texe__, __tCompile_texe__, __tCompile_exe__, __smart_translate_texe_to_exe__. Думаю, что они делают интуитивно понятно.

Кстати, если вместо __tnasь__ с эмулятором использовать __tnasm__ с дальнейшей трансляцией в PE формат, ты выигрыш по времени составит 45 раз.

Более того инструменты для работы с PE форматом (__tPE_Editor.h__) можно использовать и без __tnasm__.

А вот некоторый простой пример конвертации машинных кодов и __tnasm__. 
![](https://github.com/timattt/Programming-C-MIPT-timattt/blob/master/exe_example.jpg)
