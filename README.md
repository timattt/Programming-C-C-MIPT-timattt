# Введение
Этот репозиторий содержит разнообразные проекты на C++.


# Сборка и тестирование
В репозитории есть CMAKE. После сборки в папке **Run** можно найти бинарники, а в папке **Examples** скрипты для демонстрации их работы.

## Запуск бинарников
**Важно!** Чтобы у вас рисовались графы, необходимо, чтобы был установлен graphwiz.
### Акинатор
Вам достаточно просто запустить бинарник из консоли, там будет интуитивно понятное управление.
### Выражения
Доступны следующие команды:   
* ``` \EXPRESSIONS.exe --calc "ВАШЕ_ВЫРАЖЕНИЕ" ``` - посчитать выражение.   
* ``` \EXPRESSIONS.exe --diff "ВАШЕ_ВЫРАЖЕНИЕ" "ВАША_ПЕРЕМЕННАЯ" ``` - взять производную по переменной.   
* ``` \EXPRESSIONS.exe --draw "ВАШЕ_ВЫРАЖЕНИЕ" "ИМЯ_КАРТИНКИ" ``` - нарисовать граф выражения.   
* ``` \EXPRESSIONS.exe --tex "ВАШЕ_ВЫРАЖЕНИЕ" ``` - написать выражение в формате TEX.  
### Грамматика
Доступны следующие команды:   
* ``` \GRAMMAR.exe "ВАША_ГРАММАТИКА" "ИМЯ_ДЛЯ_ГЕНЕРАЦИИ" ``` - создать исходник по заданным правилам.
### Компиляторы
Доступны следующие команды:   
* ``` \COMPILERS.exe --compile --texe "TASM_ИСХОДНИК" "TEXE_РЕЗУЛЬТАТ" ``` - скомпилировать TASM в TEXE    
* ``` \COMPILERS.exe --run --texe "TEXE" ``` - запустить TEXE     
* ``` \COMPILERS.exe --run --exe "EXE" ``` - запустить EXE
* ``` \COMPILERS.exe --transToSys --texe "TEXE_ИСХОДНИК" "EXE_РЕЗУЛЬТАТ" ``` - транслировать TEXE в EXE    
* ``` \COMPILERS.exe --disasm --texe "TEXE_ИСХОДНИК" "TASM_РЕЗУЛЬТАТ" ``` - дизассемблировать TEXE в TASM

### Интерпретатор
Доступны следующие команды:   
* ``` INTERPRITATOR.exe "ВАШ_ИСХОДНИК" ``` - зупастить программу   

# Проекты

## Компилятор компиляторов
Пожалуй один из самых полезных проектов - алгоритм, позволяющий построить универсальный код для любой грамматики.
Полученный код сможет сгенерировать дерево грамматики для любой подходящей строки и дальнейшее взяимодействие с ним на усмотрение разработчика. (например можно начать исполнять это дерево, если оно представляет из себя последовательность команд (см. далее))

### Правила написания грамматики
- Каждая строка - нетерминал.
- Скобки есть только квадратные для описания терминальных символов.
- Если используем оператор | (или), то в каждой части оператора может быть только один нетерминал И БОЛЬШЕ НИЧЕГО,
приоритет идет слева.
- Можно задавать терминальные символы в квадратных скобках.
Внутри скобок выбирается строка, из заключенных в кавычки,
если в кавычках поставить два символа и между ними тире, то может быть выбран любой символ,
лежащий между этими двумя.
- После нетерминала можно ставить следующие операторы:
1. "*" - ноль или более.
2. "+" - один или более.
3. "?" - ноль или один.
- Нужно быть осторожным, когда есть два нетерминала с одинаковым началом.
- Результат работы парсера - дерево, где каждая вершина - нетерминал, ее сыновья - нетерминалы, которые вызываются данным нетерминалом.
В ней хранится значение, которое склеивается из значений сыновей. Если в определении вершины-нетерминала есть терминалы,
то они просто добавляются в значению данной вершины.

### Пример
Пусть мы хотим написать парсер, который будет анализировать строки вида имя, двоеточие, номер.

![Image of example](https://github.com/timattt/Project-cpp/blob/master/About/gram_example.png)

### Примеры грамматик
- __A ::=...;__  \(Объявляем нетерминал А)
- __A ::=["abc"];__  (Нетерминал А определен как строка "abc")
- __A ::= B | C | D;__  (Если B подходит, то в A используется B, если нет, то проверяется C и т.д.)
- __A ::= ["abc" "b-z"];__  (Нетерминал А может быть одной из строк "abc" или одним символом из диапазона [b, z])
- __А ::= B*;__  (Пока нетерминал B присутствует он будет использован)
- __A ::= ["abcd"]E;__
__B ::= ["abcd"]C;__ (C, E - другие нетерминалы)
__D ::= A | B;__ (Вот в этом месте может возникнуть неопределенность)
- __A ::= C;__
__C ::= B["de"];__
__B ::= "abc";__
Результат работы для строки "abcde" (это дерево, в скобках указано значение, которое лежит в вершине)
A("abcde") -> C("abcde") -> B("abc")

## Интерпретатор
В конце первого семестра я написал язык программирования, но это был интерпретируемый язык, т.е. он выполнялся непосредственно в виде дерева, без перехода в асм, синтаксис примерно похож на C.
Вот простойт пример работы интерпретатора. Программа вычисляет значение (2*n)!
![](https://github.com/timattt/Project-cpp/blob/master/About/lang_example.png)

## Компиляторы
Вот крупный подпроект на тему компиляторов. Тут есть мой собственный ассемблер, который можно преобразовать в самодельный машинный код, после чего запустить.
Более того, этот самодельный машинный код можно транслировать в реальный байт-код архитектуры x86, в процессе просто будет создан обычный exe-шник. 
Вот наглядная иллюстрация работы всего этого.
![](https://github.com/timattt/Project-cpp/blob/master/About/exe_example.jpg)

## Выражения
Небольшая задача о калькуляторе. Эта программа может посчитать заданное выражение, может продифференцировать заданное выражение,
может нарисовать кравивое двоичное дерево этого выражения. Может преобразовать выражение в TEX.

## Акинатор
Самодельный аналог известной программы https://ru.akinator.com/
