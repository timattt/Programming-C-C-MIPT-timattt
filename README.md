# Введение
Сей репозиторий содержит мои проекты, написанные в первом семестре обучения на ФРТК.
Из них можно выделить несколько, представляющие наибольший интерес, краткая сводка по ним следует далее.

# Компилятор компиляторов
Пожалуй один из самых полезных проектов - алгоритм, позволяющий построить универсальный код для любой грамматики.
Полученный код сможет построить дерево грамматики для дальнейших с ним взаимодействий на усмотрение разработчика.

## Правила написания грамматики
- Каждая строка - нетерминал.
- Скобки есть только квадратные для описания терминальных символов.
- Если используем оператор | (или), то в каждой части оператора может быть только один нетерминал И БОЛЬШЕ НИЧЕГО,
приоритет идет слева.
- Можно задавать терминальные символы в квадратных скобках.
Внутри скобок выбирается строка, из заключенных в кавычки,
если в кавычках поставить два символа и между ними тире, то может быть выбран любой символ,
лежащий между этими двумя.
- После нетерминала можно ставить следующие операторы:
1. "*" - ноль или более.
2. "+" - один или более.
3. "?" - ноль или один.
- Нужно быть осторожным, когда есть два нетерминала с одинаковым началом.
- Результат работы парсера - дерево, где каждая вершина - нетерминал, ее сыновья - нетерминалы, которые вызываются данным нетерминалом.
В ней хранится значение, которое склеивается из значений сыновей. Если в определении вершины-нетерминала есть терминалы,
то они просто добавляются в значению данной вершины.

## Примеры
- __A ::=...;__ (Объявляем нетерминал А)
- __A ::=["abc"];__ (Нетерминал А определен как строка "abc")
- __A ::= B | C | D;__ (Если B подходит, то в A используется B, если нет, то проверяется C и т.д.)
- __A ::= ["abc" "b-z"];__ (Нетерминал А может быть одной из строк "abc" или одним символом из диапазона [b, z])
- __А ::= B*;__ (Пока нетерминал B присутствует он будет использован)
- __A ::= ["abcd"]E;__
__B ::= ["abcd"]C;__ (C, E - другие нетерминалы)
__D ::= A | B;__ (Вот в этом месте может возникнуть неопределенность)
- __A ::= C;__
__C ::= B["de"];__
__B ::= "abc";__
Результат работы для строки "abcde" (это дерево, в скобках указано значение, которое лежит в вершине)
A("abcde") -> C("abcde") -> B("abc")
