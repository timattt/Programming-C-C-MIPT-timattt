### Введение
Сей репозиторий содержит мои проекты, написанные в первом семестре обучения на ФРТК.
Из них можно выделить несколько, представляющие наибольший интерес, краткая сводка по ним следует далее.

### Компилятор компиляторов
Пожалуй один из самых полезных проектов - алгоритм, позволяющий построить универсальный код для любой грамматики.
Полученный код сможет построить дерево грамматики для дальнейших с ним взаимодействий на усмотрение разработчика.

## Правила написания грамматики
- Каждая строка - нетерминал.
# ПРИМЕР: A ::=...; (Объявляем нетерминал А)
- Скобки есть только квадратные для описания терминальных символов.
# ПРИМЕР: A ::=["abc"];(Нетерминал А определен как строка "abc")
- Если используем оператор | (или), то в каждой части оператора может быть только один нетерминал И БОЛЬШЕ НИЧЕГО,
приоритет идет слева.
# ПРИМЕР: A ::= B | C | D; (Если B подходит, то в A используется B, если нет, то проверяется C и т.д.)
- Можно задавать терминальные символы в квадратных скобках.
Внутри скобок выбирается строка, из заключенных в кавычки,
если в кавычках поставить два символа и между ними тире, то может быть выбран любой символ,
лежащий между этими двумя.
# ПРИМЕР: A ::= ["abc" "b-z"]; (Нетерминал А может быть одной из строк "abc" или одним символом из диапазона [b, z])
- После нетерминала можно ставить следующие операторы:
1. "*" - ноль или более.
2. "+" - один или более.
3. "?" - ноль или один.
# ПРИМЕР: А ::= B*; (Пока нетерминал B присутствует он будет использован)
- Нужно быть осторожным, когда есть два нетерминала с одинаковым началом.
# ПРИМЕР: A ::= ["abcd"]E;
B ::= ["abcd"]C; (C, E - другие нетерминалы)
D ::= A | B; (Вот в этом месте может возникнуть неопределенность)
- Результат работы парсера - дерево, где каждая вершина - нетерминал, ее сыновья - нетерминалы, которые вызываются данным нетерминалом.
В ней хранится значение, которое склеивается из значений сыновей. Если в определении вершины-нетерминала есть терминалы,
то они просто добавляются в значению данной вершины.
# ПРИМЕР: A ::= C;
C ::= B["de"];
B ::= "abc";

Результат работы для строки "abcde" (это дерево, в скобках указано значение, которое лежит в вершине)
A("abcde") -> C("abcde") -> B("abc")
